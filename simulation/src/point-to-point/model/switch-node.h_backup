#ifndef SWITCH_NODE_H
#define SWITCH_NODE_H

#include <unordered_map>
#include <ns3/node.h>
#include "qbb-net-device.h"
#include "switch-mmu.h"
#include "pint.h"
#include "tower.h"

namespace ns3 {

class Packet;

class SwitchNode : public Node{
	static const uint32_t pCnt = 257;	// Number of ports used
	static const uint32_t qCnt = 8;	// Number of queues/priorities used
	uint32_t m_ecmpSeed;
	std::unordered_map<uint32_t, std::vector<int> > m_rtTable; // map from ip address (u32) to possible ECMP port (index of dev)

	// monitor of PFC
	uint32_t m_bytes[pCnt][pCnt][qCnt]; // m_bytes[inDev][outDev][qidx] is the bytes from inDev enqueued for outDev at qidx

	uint64_t m_txBytes[pCnt]; // counter of tx bytes

	//
	//uint64_t m_txBytes_old[pCnt];
	//uint64_t m_txBytes_new[pCnt];

	uint32_t m_lastPktSize[pCnt];
	uint64_t m_lastPktTs[pCnt]; // ns
	double m_u[pCnt];


	bool isCounting[pCnt];			//flag，用于判断当前是否需要进行统计
	bool countStart[pCnt];			//统计周期开始的标记，用于触发何时结束统计周期
	uint16_t pktCount[pCnt];		//统计周期内包个数计数
	uint8_t minPos[pCnt];			//统计周期内记录到的最低速率
	uint8_t maxPos[pCnt];			//统计周期内记录到的最高速率
	double preMinPos[pCnt];			//记录上一个统计周期内的最低速率
	double preMaxPos[pCnt];			//记录上一个统计周期内的最高速率
	bool m_fair[pCnt];				//flag，用于判断当前网络是否稳定
	bool writeStart[pCnt];			//写入周期开始的标记，用于触发何时结束写入周期
	uint64_t count_T;				//经过该时间，将isCounting[pCnt]设置成false，结束统计周期
	uint64_t fair_T;				//经过该时间，开启下一轮的统计
	uint8_t stage[pCnt];			//用于延长fair_T

	uint16_t rateCnt[pCnt][10];		//实时记录当前周期的速率分布情况
	//uint16_t rateCntOld[pCnt][20];	//将上一个周期的分布情况保存，用来分析

	//uint64_t rateCntOld1[pCnt][10];
	//uint64_t rateCntOld2[pCnt][10];
	//uint64_t rateCntOld3[pCnt][10];
	//uint64_t rateCntOld4[pCnt][10];

	//bool isFirst[pCnt];					//a flag to judge whether to start the Timer
	//bool checking[pCnt];
	//int target_pos[pCnt];
	//uint32_t rateIdx[pCnt];
	//bool newFlow[pCnt];
	//bool config[pCnt];
	//TowerSketchHalfCU *tcm_new;				//Use approximate conservative update to count
	//std::unordered_map<uint64_t, bool> LFT;	//use a table to record long flow
	//uint32_t m_bytes_new[pCnt][qCnt];		//monitor of new flows
	//uint32_t lftCnt = 0;
	//uint32_t flows[pCnt];
	//uint32_t flows_old[pCnt];
	//bool flowsteady[pCnt];


protected:
	bool m_ecnEnabled;
	uint32_t m_ccMode;
	uint64_t m_maxRtt;

	uint32_t m_ackHighPrio; // set high priority for ACK/NACK

private:
	int GetOutDev(Ptr<const Packet>, CustomHeader &ch);
	void SendToDev(Ptr<Packet>p, CustomHeader &ch);
	static uint32_t EcmpHash(const uint8_t* key, size_t len, uint32_t seed);
	void CheckAndSendPfc(uint32_t inDev, uint32_t qIndex);
	void CheckAndSendResume(uint32_t inDev, uint32_t qIndex);
public:
	Ptr<SwitchMmu> m_mmu;

	static TypeId GetTypeId (void);
	SwitchNode();
	void SetEcmpSeed(uint32_t seed);
	void AddTableEntry(Ipv4Address &dstAddr, uint32_t intf_idx);
	void ClearTable();
	bool SwitchReceiveFromDevice(Ptr<NetDevice> device, Ptr<Packet> packet, CustomHeader &ch);
	void SwitchNotifyDequeue(uint32_t ifIndex, uint32_t qIndex, Ptr<Packet> p);

	// for approximate calc in PINT
	int logres_shift(int b, int l);
	int log2apprx(int x, int b, int m, int l); // given x of at most b bits, use most significant m bits of x, calc the result in l bits

	void countEnd(uint32_t p);
	void writeEnd(uint32_t p);
	void nextCount(uint32_t p);
	//void updateRtCnt(bool first, int p);
	//bool isSteady(uint32_t p);
	//int slowestPos(uint64_t rateCnt[]);
	//int highestPos(uint32_t p);
	//int highest(uint64_t rateCnt[]);
	//int existPos(uint64_t rateCnt[]);
	//void checkFair(uint32_t p);
	//void controlSpeed(uint32_t p);
	//uint16_t packetCount(uint32_t p);

	//bool newFlow(uint32_t p);
	// void updateFlowState(uint32_t p);
	// void updateSketch();
	// void updateLFT();
	//void updateConfig(uint32_t p);
	//void isFlowSteady(uint32_t idx);
};

} /* namespace ns3 */

#endif /* SWITCH_NODE_H */
